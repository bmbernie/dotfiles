#!/usr/bin/env bash
# Copyright (c) 2013, Brandon Bernie
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

#############################################################################
# Author: Brandon Bernie
# Email : bmbernie@gmail.com
# File  : .functions
# OS    : Mac OS X [Tested on Mavericks]
#############################################################################

function pman()
{
  man -t "${1}" | open -f -a /Applications/Preview.app
}

# Change working directory to the top-most Finder window location
#cdf - Change Directory to the active Finder window (else ~/Desktop)
function cdf()
{
  local fPath=`osascript -e '
        tell app "finder"
            try
                  set folderPath to (folder of the front window as alias)
                      on error
                            set folderPath to (path to desktop folder as alias)
                                end try
                                      POSIX path of folderPath
  end tell'
  `;
  echo "cd $fPath";
  cd "$fPath" > /dev/null
}

function targz() {
  local tmpFile="${@%/}.tar"
  tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1
  
  size=$(
    stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
    stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
  )
  
  local cmd=""
  if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
    # the .tar file is smaller than 50 MB and Zopfli is available; use it
    cmd="zopfli"
  else
    if hash pigz 2> /dev/null; then
      cmd="pigz"
    else
      cmd="gzip"
    fi
  fi
  
  echo "Compressing .tar using \`${cmd}\`…"
  "${cmd}" -v "${tmpFile}" || return 1
  [ -f "${tmpFile}" ] && rm "${tmpFile}"
  echo "${tmpFile}.gz created successfully."
}

# Determine size of a file or total size of a directory
function fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh
  else
    local arg=-sh
  fi
  if [[ -n "$@" ]]; then
    du $arg -- "$@"
  else
    du $arg .[^.]* *
  fi
}

# Use Git’s colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
  function diff() {
    git diff --no-index --color-words "$@"
  }
fi

# Compare original and gzipped file size
function gz() {
  local origsize=$(wc -c < "$1")
  local gzipsize=$(gzip -c "$1" | wc -c)
  local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
  printf "orig: %d bytes\n" "$origsize"
  printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# All the dig info
function digga() {
  dig +nocmd "$1" any +multiline +noall +answer
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
  if [ -z "${1}" ]; then
    echo "ERROR: No domain specified."
    return 1
  fi
  
  local domain="${1}"
  echo "Testing ${domain}…"
  echo # newline
  
  local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
  | openssl s_client -connect "${domain}:443" 2>&1);
  
  if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
    local certText=$(echo "${tmp}" \
      | openssl x509 -text -certopt "no_header, no_serial, no_version, \
    no_signame, no_validity, no_issuer, no_pubkey, no_sigdump, no_aux");
    echo "Common Name:"
    echo # newline
    echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//";
    echo # newline
    echo "Subject Alternative Name(s):"
    echo # newline
    echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
    | sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
    return 0
  else
    echo "ERROR: Certificate not found.";
    return 1
  fi
}

# flac -> conversion script
function flactomp3(){
  for f in *.flac; 
    do ffmpeg -i "$f" -acodec libmp3lame -ab 320k  "${f%.flac}.mp3"; 
  done
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
  tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX
}

function me(){
  # local variables
  local engagement_path=$HOME/engagements/$1
  local tools_path=$HOME/tools

  if [ -f $engagement_path ]; then
    echo "Error: The $CYAN ${1} project already exists"
    return 1
  fi

  if [ -d $engagement_path ]; then
    echo "Error: The $CYAN ${1} project already exists"
    return 1
  fi

  mkdir $engagement_path/
  mkdir $engagement_path/config
  mkdir $engagement_path/output
  mkdir $engagement_path/src
  mkdir $engagement_path/bin
  
  cp -R $HOME/Documents/templates/WAPT_Methodology_v1.5.1.numbers $engagement_path/WAPT_Methodology_v1.5.1.numbers
  cd $engagement_path
  mv WAPT_Methodology_v1.5.1.numbers wapt-$1.numbers 

  # update various tools and copy configs
  cd $tools_path/sqlmap_dev
  echo -e "Updating sqlmap ...\n"
  /usr/local/bin/python sqlmap.py --update
  cp sqlmap.conf $engagement_path/config/sqlmap_$1.conf

  cd $tools_path/nikto-2.1.5
  echo ""
  echo -e "Updating nikto ...\n"
  /usr/bin/perl nikto.pl --update
  cp nikto.conf $engagement_path/config/nikto_$1.conf

  cd $tools_path
  echo ""
  echo "Updating: testssl ..."
  cd testssl.sh
  git pull origin master
  
  echo "#!/usr/local/bin/bash" > $HOME/.dotfiles/.engagement
  echo "export ENGAGEMENT=$engagement_path/bin" >> $HOME/.dotfiles/.engagement
  
  
  export ENGAGEMENT="$engagement_path/bin"
  export PATH="$ENGAGEMENT:$PATH"
  

  #copy scripts over for tools
  cd $HOME/tools/burp
  cp scripts/sb $ENGAGEMENT/sb
  cp scripts/ff $ENGAGEMENT/ff
  cd $ENGAGEMENT

  # Sqlmap config
  echo "#!/usr/local/bin/bash" > sqlmap
  echo "PARAMS=("\$@")" >> sqlmap
  echo "declare -a NEWPARAMS" >> sqlmap
  echo "for ((i=1; i <= \$#-1; i++)); do NEWPARAMS=( "\${NEWPARAMS[@]}" "\${PARAMS[\$i]}" ); done;" >> sqlmap
  echo "if [ \$1 ]; then" >> sqlmap
  echo "  /usr/local/bin/python $tools_path/sqlmap-dev/sqlmap.py -c $engagement_path/config/sqlmap_$i.conf -u \$1 \${NEWPARAMS[@]}" >> sqlmap
  echo "else" >> sqlmap
  echo "/usr/local/bin/python $tools_path/sqlmap-dev/sqlmap.py -c $engagement_path/config/sqlmap_$i.conf \$@" >> sqlmap
  echo "fi" >> sqlmap
  chmod 700 sqlmap


  # Nikto configuration
  echo "#!/usr/local/bin/bash" > nikto

  echo "if [ -z $1 ];then" >> nikto
  echo "  echo "Error: No Hostname"" >> nikto
  echo "  exit" >> nikto
  echo "fi" >> nikto

  echo "HOSTNAME=\`echo \$1 | awk -F/ '{print \$3}'\`" >> nikto
  echo "PROTOCOL=\`echo \$1 | awk -F/ '{print \$1}'\`" >> nikto
  echo "PARAMS=("\$@")" >> nikto
  echo "declare -a NEWPARAMS" >> nikto
  echo "for ((i=1; i <= \$#-1; i++)); do NEWPARAMS=( "\${NEWPARAMS[@]}" "\${PARAMS[\$i]}" ); done;" >> nikto
  echo "if [ "\$1" = "https:" ]; then" >> nikto
  echo "  perl $tools_path/nikto-2.1.5/nikto.pl -useproxy -config $engagement_path/config/nikto_$i.conf -Format htm -host \$HOSTNAME -port 443 -output $engagement_path/output/\$HOSTNAME.htm -ssl -vhost \$HOSTNAME -useproxy https://localhost:8080 \${NEWPARAMS[@]}" >> nikto
  echo "fi" >> nikto
  echo "perl $tools_path/nikto-2.1.5/nikto.pl -useproxy -config $engagement_path/config/nikto_$i.conf -Format htm -host \$HOSTNAME -port 80 -output $engagement_path/output/\$HOSTNAME.htm -vhost \$HOSTNAME -useproxy http://localhost:8080 \${NEWPARAMS[@]}" >> nikto
  chmod 700 nikto

  # TestSSL 
  echo "" > testssl.sh
  echo "PARAMS=("\$@")" >> testssl.sh
  echo "declare -a NEWPARAMS" >> testssl.sh
  echo "for ((i=1; i <= $#-1; i++)); do NEWPARAMS=( "\${NEWPARAMS[@]}" "\${PARAMS[$i]}" ); done;" >> testssl.sh
  echo "#!/usr/local/bin/bash" >> testssl.sh
  echo "export OPENSSL=/usr/local/Cellar/openssl/1.0.1i/bin/openssl" >> testssl.sh
  echo "$tools_path/testssl.sh/testssl.sh \$1 ${NEWPARAMS[@]}" >> testssl.sh
  chmod 700 testssl.sh


  echo -e "\nProject created: $ORANGE $1"
  cd $engagement_path
}
